<html>
  <head>
    <style type="text/css">
      body {
        font-family: helvetica, sans-serif}
      canvas {
        margin: 40px;
      }
      a {
        display: inline-block;
        background: #333;
        padding: 0.5rem 1rem;
        color: #fff;
        text-align: center;
        text-decoration: none;
        margin: 5px 5px 20px 0;
        font-size: 1.5rem;
        }
      a:hover {
        background: #666;
      }
    </style>
    <script src="p5.min.js"></script>
    <!-- NOT WORKING.... (at least, not when running locally off the filesystem) -->
    <script src="p5.svg.js"></script>
    <script src="file_saver.js"></script>
    <script language="javascript">

    var canvas;
    margin = 40; //match document margin

    var foreground_color;
    var background_color;

    function setThickness(t) {
      strokeWeight(t);
    }

    function setup() {
      //createCanvas(window.innerWidth-margin*2, window.innerHeight-margin*2,SVG);
      //createCanvas(window.innerWidth-margin*2, window.innerHeight-margin*2);
      //square on mobile
      //createCanvas(window.innerWidth-margin*2, window.innerWidth-margin*2,SVG);
      //if we're probably on a desktop
      //go with SVG
      if(window.innerWidth > 800) {
        canvas = createCanvas(window.innerWidth-margin*2, window.innerWidth-margin*2,SVG);
      }else {
        //regular canvas (much faster for mobile :)
        canvas = createCanvas(window.innerWidth-margin*2, window.innerWidth-margin*2);
      }
      //createCanvas(600, 200, SVG); // Create SVG Canvas

      //createCanvas(window.innerWidth-margin*2, window.innerWidth-margin*2);
    }

    function grid(margin,w,h) {
      noFill();
      strokeWeight(0.5);
      stroke("#000");
      cols = 400;
      rows = 400;
      x = y = margin;

      for(row = 0; row < rows; row++){
        for (col=0; col < cols; col++) {
            rect(x,y,w,h);
            x = (width * -2) + margin + (col * (w + margin))
            y = (height * -2) + margin + (row * (h + margin)) + (h/2 * (col % 2));
        }
      }
    }

    function poly_line_mountain() {
      clear();
      //noFill();
      noStroke()
      maxShade = 250
      minShade = 20;
      smoothness = height*Math.random();
      xSteps = width * Math.random();
      setThickness(0.2)
      how_many = 2;
      first_y = y = height * rando(0.2, 0.6);
      for(i = 0; i < how_many; i ++) {
        x = 0;
        beginShape();
        while(x < width) {
          vertex(x,y);
          x += rando(width/xSteps,width/xSteps);
          y += rando(-height/smoothness, height/smoothness);
        }

        vertex(width,y);
        vertex(width,height);
        vertex(0,height);
        vertex(0,first_y);
        endShape();

        shade = minShade + ((maxShade - minShade) * (1-(i/how_many)));
        fill(shade, shade, shade);

        console.log(shade);
        y += rando(height/80,height/20);

      }
    }

    function mountains() {
      clear();
      x = 0;//rando(0, width/800);
      y = height * rando(0.4, 0.6);
      //space = width/900; //width/rando(300,800);
      thickness = 1;
      //thickness = rando(0.025,0.05);
      space = thickness;
      strokeWeight(thickness);
      shade = 240;
      flatness = rando(40,700); //higher is less craggy
      dy = rando(-height/flatness, height/flatness);
      resolution = rando(0.3, 0.9);

      while( y < height) {
        stroke(shade, shade, shade);
        line(x,y,x,height);
        y += dy
        if(Math.random()> resolution){
          dy = rando(-height/flatness, height/flatness);
        }
        x += space //rando(space*0.9, space*1.1);
        if(x >= width) {
          resolution = rando(0.3, 0.6);
          //flatness = rando(100,900); //higher is less craggy
          shade *= 0.7
          //x = 0;
          x = 0//rando(0, width/800);
          y += rando(height/50, height/15); //rando(height/50, height/20);
          //thickness *= 1.3;
          strokeWeight(thickness);
          debug(y);
          debug(height);
        }
      }
    }

    function debug(msg) {
      console.log(msg);
    }

    function pattern() {
      clear();
      turns = 3;
      margin = width/(50+(Math.random()*150));
      w = margin * Math.random()*4;
      h = w * Math.random()*4;

      for(i = 0 ; i < turns; i ++ ) {
        rotate(PI/turns);
        translate(width/-5,height/-2)
        grid(margin,w,h);
      }
    }

    function hydroVents() {
      //stroke(rando(0,255),rando(0,255),rando(0,255));
      //stars();
      for(j = 0; j < 3; j++) {
        fuzzyChain();
      }
    }


    function fuzzyChain () {
        //x1 = rando(0,)
        //walk the chain, use the previous radius + new radius
        x = rando(0,width);
        y = height;
        max_rad = width/200;
        min_rad = max_rad / 2;
        max_fuzz = 0.08;
        i = 0;
        rad = rando(min_rad, max_rad);
        while(y > 0 && i < 50) {
            thickness = 0.025;
            turns = rando(10,5000);
            fuzziness = rando(max_fuzz * 0.1, max_fuzz)
            star(x,y,rad,thickness, turns, fuzziness);
            angle = (2*Math.PI) + rando(-Math.PI*0.8, Math.PI*0.8);
            old_rad = rad;
            rad = rando(min_rad, max_rad);
            max_rad *= 1.008;
            max_fuzz *= 1.006;
            distance = (rad + old_rad);
            /*old_x = x;
            old_y = y;
            line(old_x, old_y, x,y);*/
            x -= sin(angle) * distance;
            y -= cos(angle) * distance;
            //console.log(y);
            //console.log(i);
            //console.log(sin(angle) * (rad + old_rad));
            //rad = new_rad;
            i++;
        }
    }

    function stars() {
      clear();
      randomInvert();
      setColors();
      how_many = rando(2,55);

      //fuzziness = rando(0,0.5);

      for(i = 0; i < how_many; i++){
        radius = width/rando(0.25,20);
        turns = rando(10,5000);
        thickness = rando(0.025,0.05);
        //per circle fuzziness
        fuzziness = rando(0.05,0.8);

        star(rando(0,width),rando(0,height),radius,thickness,turns, fuzziness);
        //console.log (rando(0,5));
      }
    }

    function rando(min,max) {
      return (min + (Math.random()*(max-min)))
    }


    function star(x,y,radius,thickness,lines, fuzziness) {
      strokeWeight(thickness);
      //stroke("#fff");
      turns = lines;
      //stroke(rando(0,255),rando(0,255),rando(0,255));
      //stroke(rando(0,50),rando(0,80),rando(30,150));


      for(var i = 0 ; i < turns; i ++ ) {
        push()
        translate(x,y);
        rotate((i * 2*PI/turns) * rando(0.99999,1.00001));
        wiggle_rad = radius * rando(1-fuzziness,1+fuzziness);
        line(-wiggle_rad,-wiggle_rad,wiggle_rad,wiggle_rad);
        pop()
      }
    }

    /*function mousePressed() {
      eval(lastFuncString + "()");
    }*/

    function keyPressed() {
      //alert(keyCode);
      if(keyCode == ENTER) {
        //data = canvas.elt.toBlob();
        var svgString = new XMLSerializer().serializeToString(document.querySelector('svg'));

        var blob = new Blob([svgString], {type: "image/svg+xml;charset=utf-8"});
        saveAs(blob, "file.svg");

        //saveSVG(SVG, "svg","thing");
      }
    }

    function randomInvert(){
      if(Math.random() < 0.5) {
        background_color = "#fff";
        foreground_color = "#000";
      }else{
        background_color = "#000";
        foreground_color = "#fff";
      }

      //background_color = "#fff";
      //foreground_color = "#005";

    }

    function setColors() {
      background(background_color);
      stroke(foreground_color);
      fill(foreground_color);
    }

    function haystack() {
      clear();
      randomInvert();
      setColors();
      margin = width/20
      x = margin
      startY = height/2;
      how_many = rando(10,800);
      ball_size = height/rando(20,200);
      setThickness(rando(width/15000,width/200));

      for(i = 0; i < how_many; i++) {
        x = rando(margin, width-margin);
        y = startY * rando(0.05,1.02);
        angle = Math.PI / 2* rando(0.9, 1.1);

        x2 = rando(margin, width-margin);
        y2 = rando(startY, height-margin);

        line(x,y, x2, y2);

        if(Math.random() > 0.5) {
          fill(background_color);
        }else{
          fill(randColor());
          //fill(foreground_color);
        }
        ellipse(x,y,ball_size);
        ellipse(x2,y2, ball_size);
        //stroke("#000");
      }
    }

    function cloud(x,y, rad, isFilled) {
      how_many = rando(4,200);
      //c = "#fff";
      /*if(foreground_color == "#000") {
        c = color(foreground_c,0,0,rando(10,30));
      }else{
        c = color(255,255,255,rando(10,30));
      }*/
      c = color(foreground_color._getRed(), foreground_color._getGreen(), foreground_color._getBlue(), rando(10,30));

      //alert(c);
      //c = color(255,255,255,10);
      for(i = 0; i < how_many; i++) {
        noFill();
        if(isFilled) {
          fill(c);
        }

        noStroke();
        stroke(c);
        rad *= 1.01
        x *= rando(0.99,1.01);
        y *= rando(0.99,1.01);
        ellipse(x,y, rad);
      }
    }

    function rando_variance(variance) {
      return rando(1-variance, 1+variance)
    }

    function skyline (height_multiplier,xScale,yScale, variance_amount) {
      //set in parent function and passed in as an argument
      //xScale = 20;
      //yScale = 10;
      margin = width/10;
      //variance_amount = rando(0,0.05) * height_mulitiplier;
      variance_amount *= height_multiplier;
      x1 = x2 = margin;
      y1 = y2 = height-margin;
      while(x2 + width/xScale * rando_variance(variance_amount) < width-(margin*2)) {
        x2 = x1 * rando_variance(variance_amount);
        y2 = (height - margin) - (height_multiplier * (margin + ((height-(margin*3)) * Math.round(Math.random() * yScale)/yScale * rando_variance(variance_amount))));

        //vert
        line(x1,y1,x2,y2);

        x1 = x2 + width/xScale * rando_variance(variance_amount);
        y1 = y2 * rando_variance(variance_amount);

        //horiz
        line(x2,y2,x1,y1);
      }

      //vert
      line(x1,y1,x1,height-margin);


    }

    function city() {
      clear();
      randomInvert();
      count = 300;
      setThickness(width/1500);
      xScale = rando(3,40);
      yScale = rando(20,80);
      //yScale = 1
      variance_amount = rando(0,0.01);
      for(i = 1; i <= count; i++ ) {
        skyline(i/count,xScale,yScale, variance_amount);
      }
    }

// TODO: Port from Spectra
/*
    function splatter() {
      class window.Specks
        constructor: (cx,cy,color) ->
          max_distance = sol.width
          min_distance = 0
          min_size = sol.width/1200
          max_size = sol.width/120
          #color = "#000"

          for i in [1..sol.rando(3,200)]
            angle = Math.PI * 2 * Math.random()
            distance = sol.rando(min_distance, max_distance)
            #size = min_size + ((max_distance - distance) / max_distance * (max_size-min_size))
            size = min_size + sol.rando(0,((max_distance - distance) / max_distance * (max_size-min_size)))

            x = cx + (Math.cos(angle) * distance)
            y = cy + (Math.sin(angle) * distance)

            #thickness = sol.rando(sol.width/800,sol.width/90)
            #console.log(x)

            sol.canvas.circle(size).cx(x).cy(y).fill({color: color})
    }
  */


    function randColor() {
      return(color(random(255),random(255),random(255)));
    }
    function clouds() {
      //clear();
      //randomInvert();
      //background_color =
      background(random(["#fc0","#0af","#fffffe","#332105","#000",randColor()]));


      //console.log(foreground_color);
      //c = color(255,255,255,10);
      how_many  = rando(2,100);
      x = width/2; //rando(margin, width-margin);
      y = height/2; //rando(height*0.2,height*0.8); //rando(margin, height-margin);

      max_rad = rando(height/50, height/10);

      //usually filled
      isFilled = (Math.random() > 0.2);

      //often colorful
      colorful = Math.random() > 0.4;

      foreground_color = randColor();


      //isFilled = true;
      for(j = 0; j < how_many; j++){

        if(colorful) {
          foreground_color = randColor();
        }

        stroke(foreground_color);
        fill(foreground_color);
        //setColors();

        rad = rando(height/500, max_rad);
        x = width * rando(0.25, 0.75);
        y = height * rando(0.25, 0.75);


        //x *= rando(0.9,1.1);
        //y *= rando(0.9,1.1);
        cloud(x,y,rad, isFilled);
      }
    }

    function city2 () {
      clear();
      maxThickness = 5;
      minThickness = 0.5;
      count = 1000;
      minWidth = width/50;
      maxWidth = width*0.2;
      minHeight = height/10;
      maxHeight = height-(margin * 2);
      margin = width/20;
      for(i = 1; i <= count; i ++) {
        maxHeight *= 0.999;
        fill("#fff");
        thickness = minThickness + (maxThickness * i / count);
        strokeWeight(thickness);

        buildingHeight = minHeight + (maxHeight * Math.random());
        //if (Math.random() > 0.95)
        //  buildingHeight *= 1.2;

        x = margin + width*Math.random()
        buildingWidth = minWidth + Math.random() * maxWidth
        if(x + buildingWidth < width - (margin*2)) {
          rect(x, height-buildingHeight, buildingWidth, buildingHeight);
        }
      }

    }

    //boom!
    //TODO: add "baseColor" parameter and do shades of that color...somehow.
    function wreath(){
      clear();
      count = 10000;
      size = width/80
      maxSize = width/20;
      minRad = width*0.15;
      maxRad = width*0.35;
      minShade = 130;
      setThickness(0.5)
      //noStroke();
      //noFill();
      for(i =0; i < count; i++) {
        angle = rando(0, Math.PI*2);
        rad = rando(minRad,maxRad);
        shade =  minShade + ((255-minShade) * (rad-minRad)/(maxRad-minRad))

        if(Math.random() > 0.5) {
          fill(0, shade*rando(0,1), shade);
        }else{
          fill(shade, shade*rando(0,1), 0);
        }
        //fill(shade*rando(0.5,1), shade*rando(0.2,0.4), 0);

        //fill(0, shade*rando(0,1), shade);

        x = width/2  + (Math.sin(angle) * rad);
        y = height/2  + (Math.cos(angle) * rad);
        size = maxSize * ((rad-minRad)/(maxRad-minRad));

        ellipse(x,y,size);
        //ellipse(width/2,height/2,height/10);
      }
    }

    function generate(whichOne) {
      eval(whichOne + "()");
      lastFuncString = whichOne;
    }

    function main() {
      //autumnExplo();
      //city();
      //city2();
      /*(setup();
      clear();
      randomInvert();
      //city();
      */
      //setColors();
      //stars();

      /*foreground_color= "#fff";
      background_color = "#000";*/
      //mountain();
      //poly_line_mountain();
      //haystack();
      //clouds();
    }
    </script>
  </head>
  <body onload="main()" onresize="setup()">
  <a href="javascript: generate('city')">City</a>
  <a href="javascript: generate('mountains')">Mtns</a>
  <a href="javascript: generate('stars')">Stars</a>
  <a href="javascript: generate('clouds')">Clouds</a>
  <a href="javascript: generate('haystack')">Haystack</a>
  <a href="javascript: generate('wreath')">Wreath</a>
  <!--a href="javascript: generate('hydroVents')">hydroVents</a-->
  <br>
    <!--<a href="javascript: save()">Save</a-->
  </body>
</html>
